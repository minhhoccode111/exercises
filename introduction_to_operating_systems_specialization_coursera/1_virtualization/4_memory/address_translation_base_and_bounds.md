# Address Translation and Memory Virtualization

### Overview

- This section explores how to efficiently virtualize memory
- **Key Questions**:
  - How can we efficiently virtualize memory?
  - How do we control which memory locations a program can access and restrict memory accesses?
  - How do we do these things efficiently?

### Introduction

- Previous concepts like **Limited Direct Execution (LDE)** allowed a program to run on hardware most of the time, while the OS intervened at critical points (e.g., system calls or interrupts) to maintain control
- The goal of memory virtualization is to provide both **efficiency and control**:
  - **Efficiency**: Achieved with hardware assistance like TLBs (Translation Lookaside Buffers) and page tables
  - **Control**: Ensures that no program can access memory other than its own

### Address Translation

- The VM system uses **address translation** to convert every memory access (e.g., fetch, load, or store) from a virtual address to a physical address
- Hardware performs address translation on each memory reference, directing it to the correct physical memory location
- The OS manages memory by keeping track of free and used spaces and only intervening when necessary

### Assumptions for Initial Virtualization Model

1. The user’s address space must be placed adjacently in physical memory
2. The size of the address space is smaller than the physical memory
3. Each address space is exactly the same size

These assumptions will be relaxed gradually to obtain a more realistic memory virtualization model

### Example of Address Translation

- Consider a simple process with a short code sequence that loads a value from memory, increments it by three, and then stores it back
- **Assembly Code Example**:

  ```assembly
  128: movl 0x0(%ebx), %eax  ; Load value into eax register
  132: addl $0x03, %eax       ; Add 3 to eax register
  135: movl %eax, 0x0(%ebx)   ; Store value back to memory
  ```

- Each instruction uses a **virtual address** for memory access, while the OS relocates it to a physical address transparently

### Transparent Relocation

- **Transparent Relocation**: The process of shifting a program’s address space in physical memory without the program being aware of it
- **Dynamic (Hardware-based) Relocation**:
  - Uses **Base and Bounds** registers to relocate address spaces and protect memory references
  - The **Base Register** is set to the starting location of the address space in physical memory
  - The **Bounds Register** ensures that addresses generated by the process are within the process’s allocated memory space

### Address Translation Using Base and Bounds

1. **Base Register**: Translates the virtual address to a physical address
   - Formula: `physical address = virtual address + base`
2. **Bounds Register**: Protects against illegal memory accesses
   - If a process generates a virtual address outside the bounds value, the CPU raises an exception

### Hardware Support for Address Translation

1. **Privileged (Kernel) Mode**:
   - Prevents user mode applications from performing privileged operations
2. **Base & Bounds Registers**:
   - Support address translation and bounds checking
3. **Translation Mechanism**:
   - Translates virtual addresses and checks if they are within bounds
4. **Privileged Instructions**:
   - Allow the OS to update base and bounds registers before running user programs
5. **Exception Handling**:
   - Raises exceptions when processes access privileged instructions or out-of-bounds memory

### Summary

- Address translation is a mechanism that allows the OS to regulate every memory access made by a process
- The **Base and Bounds virtualization** technique protects against memory references outside a process’s address area
- This approach can cause internal fragmentation when address spaces are placed in fixed-sized slots in physical memory

### Lab: Address Translation with Base & Bounds

1. Use the provided `relocation.py` simulator to see how address translations work in a system with base and bounds registers
2. **Run the simulator without the `-c` flag** to generate a set of translations and see if you can perform the address translations yourself
3. **Run with the `-c` flag** to check your answers and see the actual physical addresses or violations

### Lab Exercise

- **Simulator Commands**:
  - `./relocation.py`: Runs the simulator with default flags
  - `./relocation.py -c`: Shows the results of translations
  - `./relocation.py -h`: Displays a list of flags and options for the simulator
- **Sample Lab Exercises**:
  - Determine if each virtual address generated is in or out of bounds
  - Experiment with different values of base and bounds registers
  - Explore how varying address space and physical memory sizes affect the percentage of valid address translations

### Concepts Covered

- **Address Translation**: Converting virtual addresses to physical addresses using base and bounds
- **Dynamic Relocation**: Transparently relocating address spaces in memory
- **Hardware Support**: Necessary components for efficient memory virtualization
- **Lab Exercises**: Practice address translation using the `relocation.py` simulator
